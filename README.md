# Платформа для разработки приложений

Платформа состоит из следующих библиотек:

Роутер: https://github.com/o-log/php-router

Работа с объектами: https://github.com/o-log/php-model

Компоненты админки: https://github.com/o-log/php-crud

Адаптер bootstrap: https://github.com/o-log/php-bt

генератор каркаса приложений: https://github.com/o-log/create_application

# Основной функционал библиотеки php-model

Трейт для загрузки объектов из БД по идентификатору с многоуровневым кэшированием (Factory).

Трейты для загрузки и сохранения объектов в БД и их удаления по идентификатору (ActiveRecord). Содержит инфраструктуру для отслеживания изменения объектов и обновления кэша. 

Библиотека для подключения конфига приложения и работы с ним.

Библиотека для выполнения sql-запросов.
 
Библиотека для работы с memcached.

Утилита для создания php-класса для новых объектов и структуры БД для него, сразу подключает нужные для работы трейты.
 
Утилита для добавления новых свойств к объектам и соответствующего изменения структуры БД.

[Утилита миграции БД для переноса изменений в структуре БД между инстансами приложения.](#sql_migration)

Библиотека вспомогательных методов для работы с урлами, редиректов, проверок и т.п.

# Пример использования

Требуется операционная система linux и установленные php, mysql и composer.

Для запуска демо приложения нужно выполнить следующие команды:

(в команду выполнения sql-скрипта нужно подставить ваш пароль mysql пользователя root, и этот же пароль надо будет указать в конфиге PHPModelTest/Config.php)

    git clone https://github.com/o-log/php-model.git
    cd php-model
    composer install
    mysql -u root -p1 < PHPModelDemo/db_init.sql
    cd public
    php5 -S localhost:8000

После этого можно открыть в браузере адрес localhost:8000

Код создания новой модели и сохранения ее в БД выглядит примерно так:

    $new_model = new \PHPModelTest\TestModel();
    $new_model->setTitle(rand(1, 1000));
    $new_model->save();

Вот пример загрузки модели из БД с использованием фабричного метода:

    $model_obj = \PHPModelTest\TestModel::factory($model_id);
    
Как выглядит класс модели:
    
    class TestModel implements \OLOG\Model\InterfaceFactory
    {
        use \OLOG\Model\FactoryTrait;
        use \OLOG\Model\ActiveRecord;
        use \OLOG\Model\ProtectProperties;

        const DB_ID = \PHPModelTest\Config::DB_NAME_PHPMODELTEST;
        const DB_TABLE_NAME = 'test_model';

        protected $id = 0;
        protected $title = '';

        public function getTitle(){
            return $this->title;
        }

        public function setTitle($title){
            $this->title = $title;
        }
    }    

# Подключение настроек

Чтобы библиотека могла получить доступ к базе данных, перед ее использованием нужно указать настройки:

    \OLOG\ConfWrapper::assignConfig(\PHPModelDemo\Config::get());
    
Это можно сделать например в начале точки входа.
    
Пример конфигурации:

    class Config
    {
        const DB_NAME_PHPMODELDEMO = 'phpmodel';
    
        public static function get()
        {
            $conf = array();
        
            $conf['db'] = array(
                self::DB_NAME_PHPMODELDEMO => array(
                    'host' => 'localhost',
                    'db_name' => 'phpmodel',
                    'user' => 'root',
                    'pass' => '1'
                ),
            );
    
            return $conf;
        }
    }

# Возможности

## ActiveRecord

Этот трейт помогает загружать и сохранять простые объекты в БД.

При загрузке (метод load()) он читает запись из таблицы БД и записывает каждое поле записи в поле объекта с соответствующим именем.

При записи (метод save()):

- если у объекта есть непустое значение поля id - обновляет в таблице БД запись с таким id. в каждое поле записи заносится значение из поля объекта с соответствующим именем.

- если у объекта пустое значение id - создает в таблице БД новую запись, получает ее id и записывает его в объект. в каждое поле записи заносится значение из поля объекта с соответствующим именем.

Для того, чтобы класс можно было использовать с activerecord, он должен:

- иметь поле id (реализовывать интерфейс interfaceLoad)

- поля объекта должны совпадать с полями таблицы в бд (в т.ч имена)

- иметь константы DB_ID и DB_TABLE_NAME

### игнорирование полей при изменении структуры таблицы БД

...

### хранение идентификатора в поле с именем, отличным от id

...

## Factory

Трейт позволяет сразу создать объект и загрузить его данные из таблицы БД по идентификатору.

Пример использования:

    $model_obj = \PHPModelTest\TestModel::factory($model_id);

Если записи с таким идентификатором в таблице нет - будет выброшено исключение.

Также фабрика предоставляет функционал сброса кэша модели при ее изменении или удалении.

## Библиотека для работы с БД

...

## Библиотека для работы с кэшом
 
...

## ProtectProperties

Сервисный трейт, выбрасывает исключения при обращении к необъявленным в классе свойствам объекта.

Можно использовать при желании, можно не использовать.

#<a name="sql_migration_"/> Миграция структуры БД

Утилита решает задачу переноса изменений в структуре БД между разными инстансами приложения: от одного разработчика к другим, на продакшен и т.п.
Чтобы выполнить на текущем инстансе новые запросы нужно запустить утилиту вручную: выполнить cli.php в корне приложения и выбрать в меню "Выполнение SQL-запросов".

Все sql-запросы, изменяющие структруру БД, сохраняются в файлах в корневой папке приложения: по одному файлу на каждую БД, используемую в приложении. Имя файла соответствует ключу конфига для данной БД.

Запросы заносятся в файл в том порядке, в котором они должны выполняться, в виде экмпортированного php-массива.
Запросы можут быть добавлены как утилитами создания и изменения моделей, так и руками напрямую в файл.

Массив запросов не содержит индексы, потому что индексы генерируются локально и могут конфликтовать если несколько разработчиков добавляют запросы одновременно в разных инстансах.

Для того, чтобы каждый запрос выполнялся на конкретном инстансе только один раз, утилита сохраняет список выполненных на данном инстансе запросов в специальной таблице в БД. Эта таблица создается при первом запуске утилиты.

В таблице сохраняется непосредственно текст запроса. Т.е. если добавить в файл еще раз запрос, который уже выполнялся - он будет проигнорирован. Это может быть проблемой если например разработчик добавил в таблицу поле, через некоторое время удалил его, а потом решил снова добавить: при этом в таблице появится второй запрос на создание поля, идентичный первому, и его нужно выполнить.
Для решения этой проблемы утилиты генерации и изменения моделей добавляют в sql-запросы случайную часть, которая делает строку запроса уникальной (в виде комментария). При добавлении запросов руками рекомендуется придерживаться этого же подхода.

# Методология

Библиотека сложилась в процессе разработки таких порталов как sportbox.ru и gmbox.ru и решает следующие задачи:

- минимальный порог вхождения разработчиков
- упрощение и ускорение разработки и поддержки кода
- максимальное быстродействие: минимум накладных расходов и простота оптимизации

Основные подходы, реализованные в библиотеке:

- минимизируем связанность кода, т.е. уменьшаем срок жизни переменных и количество данных, передаваемых внутри кода:
    - между компонентами передаем только минимально необходимые данные
    - переменные (в т.ч. объекты) инициализируем непосредственно перед использованием. Если объект используется много раз - получаем его из фабрики много раз. Многоуровневое кэширование в фабрике делает операцию получения объекта дешевой.
    - вместо объектов всегда передаем их идентификаторы
    - контекст не передаем во внутренние функции/шаблоны, а получаем его прямо там из провайдеров (контроллеров и т.п.)
- все операции выполняются явно

# Тесты

Скрипт test.sh в корневой папке запускает тесты.